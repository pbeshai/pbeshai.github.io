{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;"},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 52.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABwJ1iMQf/xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEAAQUCIv8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxAAAQQDAAAAAAAAAAAAAAAAMQABIWERIEH/2gAIAQEAAT8h5aFoxacwNP/aAAwDAQACAAMAAAAQL9//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QTZ//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAHBABAAIBBQAAAAAAAAAAAAAAAQARECFBUXGR/9oACAEBAAE/EKHTfKNj9F3CDOqbOf/Z'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px #fff;","alt":"Screenshot of regl animation example","title":"","src":"/static/a95c8b157796ece752d4af68b20c0db1/6af20/regl_particles_header.jpg","srcSet":["/static/a95c8b157796ece752d4af68b20c0db1/d46c0/regl_particles_header.jpg 175w","/static/a95c8b157796ece752d4af68b20c0db1/f0a7f/regl_particles_header.jpg 350w","/static/a95c8b157796ece752d4af68b20c0db1/6af20/regl_particles_header.jpg 700w","/static/a95c8b157796ece752d4af68b20c0db1/f4444/regl_particles_header.jpg 960w"],"sizes":["(max-width:","700px)","100vw,","700px"]},"children":[]},{"type":"text","value":"\n  "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I've got a fever, and the only prescription is more points dancing across my screen. In a previous blog post, I covered "},{"type":"element","tagName":"a","properties":{"href":"https://bocoup.com/blog/smoothly-animate-thousands-of-points-with-html5-canvas-and-d3"},"children":[{"type":"text","value":"how to animate thousands of points using HTML5 canvas and d3"}]},{"type":"text","value":", but that approach doesn't scale too well beyond 10,000 points. Perhaps you can push it to 20,000 if you don't mind dropping a frame here or there, but if you "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"need"}]},{"type":"text","value":" that buttery smoothness, you're going to want to switch from the 2D canvas to using WebGL. And who doesn't need buttery smoothness?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now I know what you're thinking, WebGL? I know what "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Web"}]},{"type":"text","value":" is, but that GL business? Sounds terrifying. And for good reason, it's a damn nightmare in here, but hey we "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"need"}]},{"type":"text","value":" more points! We can't give up now. Luckily, a "},{"type":"element","tagName":"a","properties":{"href":"https://uber.github.io/deck.gl/#/"},"children":[{"type":"text","value":"few"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"https://threejs.org/"},"children":[{"type":"text","value":"brave"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"http://www.pixijs.com/"},"children":[{"type":"text","value":"souls"}]},{"type":"text","value":" have written abstractions on top of WebGL to make it easier to work with. In this post, I'll explore using "},{"type":"element","tagName":"a","properties":{"href":"http://regl.party/"},"children":[{"type":"text","value":"regl"}]},{"type":"text","value":", one such library by "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/mikolalysenko"},"children":[{"type":"text","value":"Mikola Lysenko"}]},{"type":"text","value":" to help do the heavy lifting."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Take note that I am a data visualization guy, not a 3D graphics guy, so my approach is based on my experience in that area."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Quick links to all 4 demos as blocks:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/28c7f3acdde4ca5a13854f06c5d7e334"},"children":[{"type":"text","value":"Drawing 100,000 points in regl"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/5309144c8a5faa3dfec5401cc850c7b5"},"children":[{"type":"text","value":"Animate 100,000 points with regl - I"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/51d05995c5410a52116f89738144c622"},"children":[{"type":"text","value":"Animate 100,000 points with regl - II"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/66f1a837ec33f787dace43e1b5039e31"},"children":[{"type":"text","value":"Animate 100,000 points with regl - III"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"So, why do we need WebGL anyway?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The problem with sticking with the 2D canvas is that we typically have a big old for loop iterating over each point and drawing it on screen with something like "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"context.fillRect()"}]},{"type":"text","value":". Since we want to maintain frame rate of 60 frames per second, we're going to need to complete all of our updating and drawing before the browser wants to draw the next frame. With 60 frames a second, that works out to less than 17ms to do all of our calculations and updates. Once we get enough iterations in our loop, we're going to exceed that threshold and end up dropping frames occasionally, making for a jumpy and far less satisfying animation."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By switching to using WebGL, we can pass over some of the effort spent iterating over points from the CPU to the GPU. The way we do that is with shaders. Luckily for us (perhaps), regl makes it really easy to dive right in and start playing around with them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Super Simple Shader Primer"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Look, I'm no WebGL or shader expert, I just want swarms of points to storm across my screen. If you really want to learn how shaders work, you should probably read some other resource like the "},{"type":"element","tagName":"a","properties":{"href":"https://thebookofshaders.com/"},"children":[{"type":"text","value":"Book of Shaders"}]},{"type":"text","value":". Alternatively, you can stare at the examples at "},{"type":"element","tagName":"a","properties":{"href":"http://regl.party/examples"},"children":[{"type":"text","value":"regl.party"}]},{"type":"text","value":" while banging your head against the wall until it begins to make a little sense (like I did)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"With that disclaimer in mind, here's a basic rundown. You've got two types of shaders: a "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"vertex"}]},{"type":"text","value":" shader and a "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"fragment"}]},{"type":"text","value":" shader. Shaders are just programs that run on the GPU, typically to produce some graphical output. A vertex shader updates a special value called "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"gl_Position"}]},{"type":"text","value":" that determines where a vertex is positioned on screen. A fragment shader updates a special value called "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"gl_FragColor"}]},{"type":"text","value":" that determines which color a pixel will be. Vertex shaders are called for "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"all points"}]},{"type":"text","value":" or vertices passed in and fragment shaders for "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"all pixels"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"That covers a "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"very"}]},{"type":"text","value":" basic (and almost my complete) understanding of shaders. Disappointing, right? I know and I'm sorry. Turns out, however, that's almost all you need to know to get started, so let's try drawing with them before we get to animating."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Drawing 100,000 points with shaders in regl"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;"},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 52.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAEDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHDlrMgEJ//xAAXEAEBAQEAAAAAAAAAAAAAAAABAgAg/9oACAEBAAEFApBzM8//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwFJ/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAQADAQAAAAAAAAAAAAAAAAEAIDEh/9oACAEBAAE/IWOwxsdp/9oADAMBAAIAAwAAABD0D//EABYRAQEBAAAAAAAAAAAAAAAAAAEREP/aAAgBAwEBPxBVtz//xAAWEQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQIBAT8QUtuf/8QAGRABAQEBAQEAAAAAAAAAAAAAAREAMRAh/9oACAEBAAE/EPqM1CC4ApzDlZ18/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px #fff;","alt":"Screenshot of regl drawing example","title":"","src":"/static/ff549e6400cd9e33cff863379997cf43/6af20/regl_draw.jpg","srcSet":["/static/ff549e6400cd9e33cff863379997cf43/d46c0/regl_draw.jpg 175w","/static/ff549e6400cd9e33cff863379997cf43/f0a7f/regl_draw.jpg 350w","/static/ff549e6400cd9e33cff863379997cf43/6af20/regl_draw.jpg 700w","/static/ff549e6400cd9e33cff863379997cf43/f4444/regl_draw.jpg 960w"],"sizes":["(max-width:","700px)","100vw,","700px"]},"children":[]},{"type":"text","value":"\n  "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here's a link to "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/28c7f3acdde4ca5a13854f06c5d7e334"},"children":[{"type":"text","value":"a working example"}]},{"type":"text","value":". If you want to take a look at all the example code at once, check it out."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now before we get to anything too fancy, let's start by defining a few constants and creating our \"dataset\" of 100,000 points."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const numPoints = 100000;\n\n// the size of the points we draw on screen\nconst pointWidth = 4;\n\n// dimensions of the viewport we are drawing in\nconst width = window.innerWidth;\nconst height = window.innerHeight;\n\n// random number generator from d3-random\nconst rng = d3.randomNormal(0, 0.15);\n\n// create initial set of points\nconst points = d3.range(numPoints).map(i => ({\n  x: (rng() * width) + (width / 2),\n  y: (rng() * height) + (height / 2),\n  color: [0, Math.random(), 0],\n}));\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ok, so we have some points. Notice anything a bit strange? The colors are arrays!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Colors in WebGL are formatted as arrays of length four (red, green, blue, alpha) with values ranging from 0 to 1 instead of their typical string format used in HTML and CSS. The code above produces points with colors ranging from rgb(0, 0, 0) to rgb(0, 255, 0). Since we're not dealing with alpha in this example, I've excluded the fourth value from the array (we'll fill it in as "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" later)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The x and y values that we specified will range from 0 to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"width"}]},{"type":"text","value":" and 0 to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"height"}]},{"type":"text","value":", also known as pixel space. This coordinate system is what we're used to when working with normal canvas or svg, but in WebGL everything lives in normalized device coordinates, which is a fancy way of saying the top left corner is at (-1, 1) and the bottom right corner is at (1, -1). We'll keep the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"width"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"height"}]},{"type":"text","value":" variables around so we can scale our x and y positions appropriately in our shader."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"The regl Draw Loop"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So we have a collection of points, now let's set up the regl drawing loop before diving into the nitty gritty of the shaders."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"// start the regl draw loop\nregl.frame(() => {\n  // clear the buffer\n  regl.clear({\n    // background color (black)\n    color: [0, 0, 0, 1],\n    depth: 1,\n  });\n\n  // draw the points using our created regl func\n  // note that the arguments are available via `regl.prop`.\n  drawPoints({ // we'll get to this function in a moment!\n    pointWidth,\n    stageWidth: width,\n    stageHeight: height,\n  });\n});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Not much going on here: we clear the background with the color black and then we call "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"drawPoints"}]},{"type":"text","value":" with a few properties, but with this code we now have a loop running 60 times a second and attempting to draw points on the screen."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"The drawPoints Function (aka "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Shader Magic"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All right, since regl is really focused around shaders, all of the work comes out when writing shader code. We can create our "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"drawPoints"}]},{"type":"text","value":" function, which will essentially connect all the information to our shaders in a way WebGL understands. Thanks regl! I "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"really"}]},{"type":"text","value":" didn't want to do that myself."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The basic structure looks like this:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const drawPoints = regl({\n  frag: 'the fragment shader string (filled in later)',\n  vert: 'the vertex shader string (filled in later)',\n\n  attributes: {\n    // each of these gets mapped to a single entry for each of\n    // the points. this means the vertex shader will receive\n    // just the relevant value for a given point.\n    position: points.map(d => [d.x, d.y]),\n    color: points.map(d => d.color),\n  },\n\n  uniforms: {\n    // by using `regl.prop` to pass these in, we can specify\n    // them as arguments to our drawPoints function\n    pointWidth: regl.prop('pointWidth'),\n\n    // regl actually provides these as viewportWidth and\n    // viewportHeight but I am using these outside and I want\n    // to ensure they are the same numbers, so I am explicitly\n    // passing them in.\n    stageWidth: regl.prop('stageWidth'),\n    stageHeight: regl.prop('stageHeight'),\n  },\n\n  // specify the number of points to draw\n  count: points.length,\n\n  // specify that each vertex is a point (not part of a mesh)\n  primitive: 'points',\n});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's breakdown that structure above."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"frag"}]},{"type":"text","value":": This is where we'll put the fragment shader code. It is passed in just as a string."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"vert"}]},{"type":"text","value":": This is where we'll put the vertex shader code, also a string."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"attributes"}]},{"type":"text","value":": Here we pass data into the drawPoints function definition. A single entry from each of the arrays specified here is passed to the vertex shader, corresponding with the point it is drawing. So each vertex shader will receive a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"position"}]},{"type":"text","value":" array with two entries "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"[x, y]"}]},{"type":"text","value":" (note: WebGL calls an array with 2 entries a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"vec2"}]},{"type":"text","value":" for vector of length 2)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"uniforms"}]},{"type":"text","value":": These are values that are the same for all points. Note that we use "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"regl.prop"}]},{"type":"text","value":" here, which makes it so we can change these values by modifying the argument to the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"drawPoints"}]},{"type":"text","value":" function accordingly when we call it from the draw loop."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"count"}]},{"type":"text","value":": The total number of points being drawn. I believe this is important for divvying up the attributes and knowing how many vertices to draw."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"primitive"}]},{"type":"text","value":": We specify that each vertex should be drawn as a point, as opposed to all being part of a single mesh. Using "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"point"}]},{"type":"text","value":" is a great choice for particle system effects like what we're going for here."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ok, with all that aside, let's dive into the shaders."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"The Fragment Shader"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To specify the fragment shader, we write it as a multi-line string. We'll keep this one as simple as we can and just set the pixel color to whatever the vertex shader passed in."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// set the precision of floating point numbers\nprecision highp float;\n\n// this value is populated by the vertex shader\nvarying vec3 fragColor;\n\nvoid main() {\n  // gl_FragColor is a special variable that holds the color\n  // of a pixel\n  gl_FragColor = vec4(fragColor, 1);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note that "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"varying"}]},{"type":"text","value":" basically means the vertex shader populates the value of this variable. Also recall how we only stored colors as arrays of length 3 (vec3), so we append a 1 to the end for the alpha channel."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"The Vertex Shader"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The vertex shader is a bit more complex, but the basics are shown below:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// per vertex attributes\nattribute vec2 position;\nattribute vec3 color;\n\n// variables to send to the fragment shader\nvarying vec3 fragColor;\n\n// values that are the same for all vertices\nuniform float pointWidth;\nuniform float stageWidth;\nuniform float stageHeight;\n\nvoid main() {\n  // update the size of a point based on the prop pointWidth\n  gl_PointSize = pointWidth;\n\n  // send color to the fragment shader\n  fragColor = color;\n\n  // gl_Position is a special variable that holds the position\n  // of a vertex.\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First, we update "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"gl_PointSize"}]},{"type":"text","value":", a special value that determines the size points are rendered on screen based on our property "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pointWidth"}]},{"type":"text","value":". Then we save the attribute "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"color"}]},{"type":"text","value":" into the varying "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"fragColor"}]},{"type":"text","value":" so that the fragment shader can read its value since it does not have access to attributes. Finally, we update "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"gl_Position"}]},{"type":"text","value":" to indicate where the vertex is positioned."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now if you'll recall, the points in WebGL space are not the same as in normal screen pixel space-- they range from (-1, 1) to (1, -1). Since we laid out our point positions in pixel space, we'll need to normalize them in our shader. Here's the full code including normalization:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// per vertex attributes\nattribute vec2 position;\nattribute vec3 color;\n\n// variables to send to the fragment shader\nvarying vec3 fragColor;\n\n// values that are the same for all vertices\nuniform float pointWidth;\nuniform float stageWidth;\nuniform float stageHeight;\n\n// helper function to transform from pixel space to normalized\n// device coordinates (NDC). In NDC (0,0) is the middle,\n// (-1, 1) is the top left and (1, -1) is the bottom right.\nvec2 normalizeCoords(vec2 position) {\n  // read in the positions into x and y vars\n  float x = position[0];\n  float y = position[1];\n\n  return vec2(\n    2.0 * ((x / stageWidth) - 0.5),\n    // invert y to treat [0,0] as bottom left in pixel space\n    -(2.0 * ((y / stageHeight) - 0.5)));\n}\n\nvoid main() {\n  // update the size of a point based on the prop pointWidth\n  gl_PointSize = pointWidth;\n\n  // send color to the fragment shader\n  fragColor = color;\n\n  // scale to normalized device coordinates\n  // gl_Position is a special variable that holds the position\n  // of a vertex\n  gl_Position = vec4(normalizeCoords(position), 0.0, 1.0);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"That's right, you can create helper functions in shaders (like we did with "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"normalizeCoords()"}]},{"type":"text","value":" above) and call them within your "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"main()"}]},{"type":"text","value":" function. Pretty cool stuff."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block;  max-width: 700px; margin-left: auto; margin-right: auto;"},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 52.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAEDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHDlrMgEJ//xAAXEAEBAQEAAAAAAAAAAAAAAAABAgAg/9oACAEBAAEFApBzM8//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwFJ/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAQADAQAAAAAAAAAAAAAAAAEAIDEh/9oACAEBAAE/IWOwxsdp/9oADAMBAAIAAwAAABD0D//EABYRAQEBAAAAAAAAAAAAAAAAAAEREP/aAAgBAwEBPxBVtz//xAAWEQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQIBAT8QUtuf/8QAGRABAQEBAQEAAAAAAAAAAAAAAREAMRAh/9oACAEBAAE/EPqM1CC4ApzDlZ18/9k='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px #fff;","alt":"Screenshot of regl drawing example","title":"","src":"/static/ff549e6400cd9e33cff863379997cf43/6af20/regl_draw.jpg","srcSet":["/static/ff549e6400cd9e33cff863379997cf43/d46c0/regl_draw.jpg 175w","/static/ff549e6400cd9e33cff863379997cf43/f0a7f/regl_draw.jpg 350w","/static/ff549e6400cd9e33cff863379997cf43/6af20/regl_draw.jpg 700w","/static/ff549e6400cd9e33cff863379997cf43/f4444/regl_draw.jpg 960w"],"sizes":["(max-width:","700px)","100vw,","700px"]},"children":[]},{"type":"text","value":"\n  "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At this point, we have all the necessary parts to draw 100,000 points on screen with regl and shaders. Check out the "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/28c7f3acdde4ca5a13854f06c5d7e334"},"children":[{"type":"text","value":"demo and full code here"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"And Now Animate"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"alt":"GIF of animation example","src":"/regl_particles_anim1-148207c088c9a754f0f4ce02b8e6992a.gif","className":["full-width-image"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here's the "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/5309144c8a5faa3dfec5401cc850c7b5"},"children":[{"type":"text","value":"live demo and full source code"}]},{"type":"text","value":" to get this initial animation working."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So, getting started drawing 100,000 points was pretty complicated. Luckily the jump from there to animating is relatively small. At this point we already have the GPU normalizing positions of the points and drawing them on screen. And we have a loop running just waiting to animate, so what's our strategy going to be?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I'm going to take a very similar approach to what I did for "},{"type":"element","tagName":"a","properties":{"href":"https://bocoup.com/blog/smoothly-animate-thousands-of-points-with-html5-canvas-and-d3"},"children":[{"type":"text","value":"animating thousands of points on canvas"}]},{"type":"text","value":", except this time all the interpolation of position is going to happen in a shader so we can use the GPU."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The basic animation process is:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Store the current position of a point as its start position"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Run a layout function on the points to get their new positions and then store them as their end positions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Tell the shader how far through the animation we are so it knows where to interpolate to"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Switch layouts after our animation completes"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Laying out the Points"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A layout algorithm can be any function that sets the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"y"}]},{"type":"text","value":" attribute on our point objects. The reason I've taken this approach is that it is a fairly common style to find in layout algorithms already made for "},{"type":"element","tagName":"a","properties":{"href":"https://d3js.org/"},"children":[{"type":"text","value":"D3"}]},{"type":"text","value":", the industry standard library for data visualization on the web. For simplicity in these examples, I'll also set "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"color"}]},{"type":"text","value":" so we can animate it easily. Here's an example layout algorithm that randomly positions points:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"function blueNormalLayout(points) {\n  // random number generator based on a normal distribution\n  // with mean = 0, std dev = 0.15\n  const rng = d3.randomNormal(0, 0.15);\n\n  points.forEach(d => {\n    // set the x and y attributes\n    d.x = (rng() * width) + (width / 2);\n    d.y = (rng() * height) + (height / 2);\n\n    // blue-green color\n    d.color = [0, 0.5, 0.9];\n  });\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now when we animate between the points, all we need to do is keep track of their start position (let's call it "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"sx, sy"}]},{"type":"text","value":") or where they currently are, and their end position ("},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"tx, ty"}]},{"type":"text","value":") based on wherever their new layout places them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This can be done with the following code:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"// make previous end the new beginning\npoints.forEach(d => {\n  d.sx = d.tx;\n  d.sy = d.ty;\n  d.colorStart = d.colorEnd;\n});\n\n// layout points, updating x, y, and color attributes\nlayout(points);\n\n// copy layout x, y, and color to end values\npoints.forEach((d, i) => {\n  d.tx = d.x;\n  d.ty = d.y;\n  d.colorEnd = d.color;\n});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The important part here is now our points contain both their start and end positions, not just their current position. This will allow the shader to interpolate between them easily. The basic shape of a point object is as follows:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"{\n  sx: start x position - number between 0 and width,\n  sy: start y position - number between 0 and height,\n  colorStart: array with 3 entries between 0 and 1,\n  tx: end x position - number between 0 and width,\n  ty: end y position - number between 0 and height,\n  colorEnd: array with 3 entries between 0 and 1\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Updating regl.frame to Animate"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We need to update our callback in "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"regl.frame"}]},{"type":"text","value":" so that it gets the duration and start time of the animation, and knows when it can switch to the next animation. The changes are relatively simple: we keep track of the time when the animation began so we can compute time elapsed, we pass in duration and start time as new props to our drawPoints function, and we check if we've exceeded the duration of the animation and if so, switch to the next layout."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"let startTime = null; // in seconds\nregl.frame(({ time }) => {\n  // keep track of start time so we can get time elapsed\n  // this is important since time doesn't reset when starting\n  // new animations\n  if (startTime === null) {\n    startTime = time;\n  }\n\n  // clear the buffer\n  regl.clear({\n    // background color (black)\n    color: [0, 0, 0, 1],\n    depth: 1,\n  });\n\n  // draw the points using our created regl func\n  // note that the arguments are available via `regl.prop`.\n  drawPoints({\n    pointWidth,\n    stageWidth: width,\n    stageHeight: height,\n\n    // here we pass in the new props:\n    duration,\n    startTime,\n  });\n\n  // if we have exceeded the maximum duration, move on to the\n  // next animation\n  if (time - startTime > (duration / 1000)) {\n    switchToNextAnimation(); // see live demo code for details\n  }\n});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Updating drawPoints for Animation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Previously we had attributes that stored the "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"current"}]},{"type":"text","value":" position and color of each point, but now we want to work with both their start and end values. To do so, we'll modify our attributes as follows:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"attributes: {\n  // each of these gets mapped to a single entry for each of\n  // the points. this means the vertex shader will receive\n  // just the relevant value for a given point.\n  positionStart: points.map(d => [d.sx, d.sy]),\n  positionEnd: points.map(d => [d.tx, d.ty]),\n  colorStart: points.map(d => d.colorStart),\n  colorEnd: points.map(d => d.colorEnd),\n},\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We'll also need a couple new uniforms that contain information about the animation as a whole. In particular, we care about how much time has elapsed between the current frame and the beginning of the animation and how long the entire animation should take."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"uniforms: {\n  // by using `regl.prop` to pass these in, we can specify them\n  // as arguments to our drawPoints function\n  pointWidth: regl.prop('pointWidth'),\n\n  // regl actually provides these as viewportWidth and\n  // viewportHeight but I am using these outside and I want to\n  // ensure they are the same numbers, so I am explicitly\n  // passing them in.\n  stageWidth: regl.prop('stageWidth'),\n  stageHeight: regl.prop('stageHeight'),\n\n  duration: regl.prop('duration'),\n  // time in ms since the prop startTime (i.e. time elapsed)\n  // note that `time` is passed by regl whereas `startTime`\n  // is a prop passed to the drawPoints function.\n  elapsed: ({ time }, { startTime = 0 }) =>\n    (time - startTime) * 1000,\n},\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"duration"}]},{"type":"text","value":" will be another prop we pass in that represents the time for the animation to run in milliseconds. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"elapsed"}]},{"type":"text","value":" is a bit trickier - its value will be computed for each frame based on the function specified. The first argument "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"time"}]},{"type":"text","value":" is populated by regl itself, while the second argument "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"startTime"}]},{"type":"text","value":" is a prop that we are going to pass in. Note that time in regl is computed in seconds, so we multiply by 1000 to get milliseconds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Update the Shader for Animation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We've reached the point where we have to dive back into our shader to update it to animate the points. Luckily for us, the changes are relatively small. In fact, we do not have to change our fragment shader at all! However, the vertex shader needs to be updated to know how far through the animation it is, and then to interpolate the start and end positions and colors accordingly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Since we have "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"elapsed"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"duration"}]},{"type":"text","value":" being passed as uniforms, we can compute how far through the animation we are by simply dividing them: "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"elapsed / duration"}]},{"type":"text","value":" (and maxing out at 1). We can then use the amazingly useful "},{"type":"element","tagName":"a","properties":{"href":"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml"},"children":[{"type":"text","value":"mix(a, b)"}]},{"type":"text","value":" function which linear interpolates any two values -- even vectors -- to figure out our current positions and colors. Let's see how this shakes out inside our main() function:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// number between 0 and 1 indicating how far through the\n// animation this vertex is.\nfloat t = min(1.0, elapsed / duration);\n\n// interpolate position\nvec2 position = mix(positionStart, positionEnd, t);\n\n// interpolate and send color to the fragment shader\nfragColor = mix(colorStart, colorEnd, t);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Besides declaring the new variables at the top of the shader, those are the only changes we have to make! What a beautiful day."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Sadly, if you looked at the animation at this point, it would be a bit boring since we left all the magic of easing out. There's this amazing module system of pre-built shader helpers called "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/stackgl/glslify"},"children":[{"type":"text","value":"glslify"}]},{"type":"text","value":" that contains "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/stackgl/glsl-easings"},"children":[{"type":"text","value":"a bunch of easing functions"}]},{"type":"text","value":" you can drop into your code, but for now we'll write our own. Let's take the cubic-in-out easing code from "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/d3/d3-ease"},"children":[{"type":"text","value":"d3-ease"}]},{"type":"text","value":" and use it to create a new function in our shader:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// helper function to handle cubic easing (copied from d3)\n// note there are premade ease functions available via glslify.\nfloat easeCubicInOut(float t) {\n  t *= 2.0;\n  t = (t <= 1.0 ? t * t * t : (t -= 2.0) * t * t + 2.0) / 2.0;\n\n  // for simplicity, max at 1 here\n  if (t > 1.0) {\n    t = 1.0;\n  }\n\n  return t;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All we have to do now is apply that function to our "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"t"}]},{"type":"text","value":" value and we'll have some smoothly eased animation taking place and we're done! Here's the full animation vertex shader:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-clike"]},"children":[{"type":"text","value":"// per vertex attributes\nattribute vec2 positionStart;\nattribute vec2 positionEnd;\nattribute vec3 colorStart;\nattribute vec3 colorEnd;\n\n// variables to send to the fragment shader\nvarying vec3 fragColor;\n\n// values that are the same for all vertices\nuniform float pointWidth;\nuniform float stageWidth;\nuniform float stageHeight;\nuniform float elapsed;\nuniform float duration;\n\n// helper function to transform from pixel space to normalized\n// device coordinates (NDC). In NDC (0,0) is middle, (-1, 1)\n// is the top left and (1, -1) is the bottom right.\nvec2 normalizeCoords(vec2 position) {\n  // read in the positions into x and y vars\n  float x = position[0];\n  float y = position[1];\n\n  return vec2(\n    2.0 * ((x / stageWidth) - 0.5),\n    // invert y since we think [0,0] is bottom left in pixel\n    // space\n    -(2.0 * ((y / stageHeight) - 0.5)));\n}\n\n// helper function to handle cubic easing (copied from d3)\n// note there are premade ease functions available via glslify.\nfloat easeCubicInOut(float t) {\n  t *= 2.0;\n  t = (t <= 1.0 ? t * t * t : (t -= 2.0) * t * t + 2.0) / 2.0;\n\n  if (t > 1.0) {\n    t = 1.0;\n  }\n\n  return t;\n}\n\nvoid main() {\n  // update the size of a point based on the prop pointWidth\n  gl_PointSize = pointWidth;\n\n  // number between 0 and 1 indicating how far through the\n  // animation this vertex is.\n  float t;\n\n  // drawing without animation, so show end state immediately\n  if (duration == 0.0) {\n    t = 1.0;\n\n  // otherwise we are animating, so use cubic easing\n  } else {\n    t = easeCubicInOut(elapsed / duration);\n  }\n\n  // interpolate position\n  vec2 position = mix(positionStart, positionEnd, t);\n\n  // interpolate and send color to the fragment shader\n  fragColor = mix(colorStart, colorEnd, t);\n\n  // scale to normalized device coordinates\n  // gl_Position is a special variable that holds the\n  // position of a vertex\n  gl_Position = vec4(normalizeCoords(position), 0.0, 1.0);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"alt":"GIF of animation example","src":"/regl_particles_anim1-148207c088c9a754f0f4ce02b8e6992a.gif","className":["full-width-image"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Once again, here's the "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/5309144c8a5faa3dfec5401cc850c7b5"},"children":[{"type":"text","value":"live demo and full source code of this animation"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So there you have it, simple point based animation in regl. We covered how to draw 100,000 points and a basic approach to animating them. However, with these same ideas, you can do even cooler animations when you start using different layouts."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here's "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/51d05995c5410a52116f89738144c622"},"children":[{"type":"text","value":"an example of animating through a set of visually pleasing layouts"}]},{"type":"text","value":", similar to what was done in my canvas post:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["giphy-embed"],"style":"width:100%;height:0;padding-bottom:65%;position:relative;"},"children":[{"type":"element","tagName":"iframe","properties":{"src":"https://giphy.com/embed/3o7bu9aq5LuVO52m5O","width":"100%","height":"100%","style":"position:absolute","frameBorder":"0","className":["giphy-embed"],"allowFullScreen":true},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And "},{"type":"element","tagName":"a","properties":{"href":"https://bl.ocks.org/pbeshai/66f1a837ec33f787dace43e1b5039e31"},"children":[{"type":"text","value":"another example that uses actual data values"}]},{"type":"text","value":" for laying out the points:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["giphy-embed"],"style":"width:100%;height:0;padding-bottom:57%;position:relative;"},"children":[{"type":"element","tagName":"iframe","properties":{"src":"https://giphy.com/embed/3o7bueOHJAxx2l7rck","width":"100%","height":"100%","style":"position:absolute","frameBorder":"0","className":["giphy-embed"],"allowFullScreen":true},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Hope you enjoyed it! Feel free to reach out to me on twitter "},{"type":"element","tagName":"a","properties":{"href":"https://twitter.com/pbesh"},"children":[{"type":"text","value":"@pbesh"}]},{"type":"text","value":" if you have any questions or comments."}]}],"data":{"quirksMode":false}},"frontmatter":{"title":"Beautifully Animate Points with WebGL and regl","demo":"https://bl.ocks.org/pbeshai/5309144c8a5faa3dfec5401cc850c7b5","description":"Learn how to draw and smoothly animate 100,000 points in a web browser with WebGL and regl.","github":null,"img":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABwJ1iMQf/xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEAAQUCIv8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxAAAQQDAAAAAAAAAAAAAAAAMQABIWERIEH/2gAIAQEAAT8h5aFoxacwNP/aAAwDAQACAAMAAAAQL9//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QTZ//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAHBABAAIBBQAAAAAAAAAAAAAAAQARECFBUXGR/9oACAEBAAE/EKHTfKNj9F3CDOqbOf/Z","width":960,"height":504,"src":"/static/a95c8b157796ece752d4af68b20c0db1/b9a43/regl_particles_header.jpg","srcSet":"/static/a95c8b157796ece752d4af68b20c0db1/b9a43/regl_particles_header.jpg 1x"}}},"date":"May 26, 2017"},"fields":{"slug":"/blog/2017-05-26-beautifully-animate-points-with-webgl-and-regl/","readingTime":{"text":"13 min read"}}}},"pageContext":{"slug":"/blog/2017-05-26-beautifully-animate-points-with-webgl-and-regl/"}}